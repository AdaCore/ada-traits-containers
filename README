
Designing new efficient containers
==================================

Goals
-----

- Containers should be efficient
  We will compare with other languages (C++, Python and Lua)

- We need to be able to add preconditions
  In particular, we need containers for SPARK. They do not have to share
  implementation with containers used in other contexts, but it would be
  nice if we could share the spec.
  Technically speaking, one of the things this imposes is to pass the
  container in parameter to the various cursor functions (Element, First,...)
  and avoid dynamic memory allocations.

- Containers must be readable from multiple tasks in parallel
  No writting in flags for instance (M223-003)

- We would like to avoid the multiplication of packages for Bounded/Unbounded,
  constrained/indefinite, formal or not,...

- Avoid a case with dangling cursors (M124-015)
  If we write a function that returns a container, and use it as:

      declare
         C : Cursor := My_Function.First;
      begin
         ... C references deallocated memory since My_Function's result
         ... has been finalized

Naming
------

'Traits' was the name used initially, inspired by the C++ notion. However,
in C++, traits are really used to extract properties from a generic type
(through template specialization, mostly), such as what is the pointed type.
That only applies to a few of our own packages.

'Signature packages' is the term used in the Ada2012 rationale to describe
generic packages with no body.

'Policy' templates is the term used in C++ (see
https://en.wikipedia.org/wiki/Policy-based_design), and that seems closest
to what we are doing here in practice. A policy is used to inject behavior
in a parent class, typically through inheritance.
Any time some design choice has to be made when implementing an algorithm,
then that choice should be abstracted in its own policy template. Then the
algorithm can be used with any version of the policy template, so that it
can be used with all possible design choices (eventually).

Proposal for using tagged types
-------------------------------

For the convenience of using the dot-notation for calling primitive operations,
we are making all containers tagged types.

However, they are not meant to be subclassed, and thus most operations are
class-wide. This provides maximum efficient (no dynamic dispatching), and
matches what is done in the C++ STL (no virtual methods).

The cursors themselves are not tagged. All cursor operations take both the
container and the cursor in parameter (to support bounded containers), and
thus the container is used in the dot-notation call (Self.Has_Element (Pos)).

One other advantage to tagged types is that this forces the instances to
be passed by reference, and thus limits the number of implicit copies
done when passing a container as a parameter to a subprogram.
They do not avoid copies when a function returns a container though.

Implementation Note: currently, the Iterable aspect requires primitive
  operations, which make it slow. It should be enhanced to accept class-wide
  operations instead, which would also remove a number of primitive operations
  on the container types.

Proposal for sharing generic algorithms
---------------------------------------

- One of the very strong limitations of the Ada containers is that they have
  no relationship with each other. As such, if we want to write an algorithm
  that counts the number of items that match a predicate, we will need several
  packages. Since lists themselves have no relationship with each other, these
  have to be generic packages specialized for each container:

     generic
        with package Lists is new Doubly_Linked_Lists (<>);
     procedure Algo;

  Let's make the algorithm container-independent. One possibility is to pass
  instead lots of formal generic parameters that describe how to manipulate
  the list and its cursors:

     generic
        type List is tagged private;
        type Cursor is private;
        with function First (Self : List) return Cursor is <>;
        ...
     procedure Algo;

  This works, but is not very convenient to instantiate, even when using
  default values for the subprogram parameters.

  The approach proposed in our new containers is to group these generic
  parameters into a set of Traits packages. These traits packages are only
  used as a grouping of parameters, and have no body. So our algorithm
  above would be declared as:

     generic
        with package Cursors is new Forward_Cursor_Traits (<>);
     procedure Algo;

  and all the functions to manipulate the cursor are available by accessing
  actual parameters of the Cursors package.

  Several such traits packages are declared in conts.ads, to describe how
  to access elements (Conts.Element_Traits) whether they are definite or
  indefinite; how to manipulate cursors (forward, bidirectional, ...)

  All provided containers will pre-instantiate those traits as appropriate,
  in particular the cursor traits. Algorithms should then be written as
  described above. In fact, it is possible to instantiate those traits
  packages for other types of containers, like the Ada containers, or even
  standard Ada arrays, as show in conts-adaptors.ads.

  With this in place, the Count_If algorithm is written only once for all
  containers that we test (definite/indefinite, Ada2012 containers or standard
  Ada arrays).

  This technique is inspired by what C++ does. In particular, the Boost Graph
  library uses it for all graph algorithms, so that they can be used on
  user-specific data structures, not just on a graph type provided by Boost.

- By convention, all _Traits packages have a plural in their name, as in
  Cursors_Traits, Elements_Traits, List_Nodes_Traits.

Proposal for sharing code
-------------------------

Currently, there is no sharing of code between Doubly_Linked_Lists,
and Indefinite_Doubly_Linked_Lists, Bounded_Doubly_Linked_Lists and
Formal_Doubly_Linked_Lists.

The proposal here is to share as much code as possible, through additional
formal generic parameters. With these, containers have several orthogonal
properties:

   - whether they accept definite or indefinite elements.
     This is configured by passing an Elements_Traits package, which is in
     charge of converting to an access type in the case of indefinite
     elements (an alternative implementation could be to reserve the maximum
     space for the element, as done in the current formal containers)

   - whether they are bounded or unbounded
     This is configured by passing a List_Nodes_Traits package. This is in
     charge of allocating the nodes, either on the heap, or as part of a
     statically allocated array of nodes. One other possible implementation
     for SPARK is to have cursors be an index into an array of access types,
     which is safer than having cursors be access types themselves and is
     needed to write some of the post conditions.

   - whether they are controlled or limited types
     The full semantics of containers a-la Ada containers requires having
     controlled types, in particular so that assignment create a copy of
     the container (or possibly a lazy copy) and automatically free
     memory.
     Alternatively, SPARK does not support controlled types, so we want to
     provide another hierarchy of limited non-controlled containers. This
     implementation provides no automatic free of the memory, the user is
     responsible for calling Clear explicitly (and the implementation in
     the nodes and element traits package an decide to do not actual free
     at all).

   - whether they are meant for SPARK usage
     Unbounded containers in SPARK are allowed to allocate memory, but we
     want the pointers to be indexes into a table, not direct pointers.
     This is safer, but also eases the writting of post-conditions since
     the value of the cursor is the same before and after an insert or a
     copy for instance.
     This is implemented as a new nodes_traits, similar to bounded and
     unbounded.

So a bounded-definite container does not memory allocation;
a bounded-indefinite container does one memory allocation for each element;
an unbounded-definite container does one memory allocation for each node;
an unbounded-indefinte container does two memory allocations per element.

Proposal for performance
------------------------

The overall goal is to get as good a performance as possible.
We propose not to use controlled types unless explicitly requested by the
user. We also propose not to handle bits in the container to invalid
containers when a container has been modified. These costs a lot (both
in performance and because this requires write access to the container
even for read-only operations, hence the user of unchecked_access).

An experiment has been done in using Reference_Type to speed up access
to data in indefinite containers. In practice, this seems slow because
a reference_type is an unconstrained type, so it might be better for
users to keep using an element_access.

Using the realloc() system call leads to large improvements over
systematically allocating a new array, copying the old, and freeing the
old. One of the drawbacks is that users should not put controlled types
that need to access their address into such a table.
This seems like an acceptable limitation given the very significant
speed improvements.
Unfortunately, there is no way to test whether the user's type conforms to
this requirement.

Proposal for tasking
--------------------

It seems that in some cases (refcounting and copy-on-write for instance), we
could use standard integer operations when no task exists in the system,
instead of the slower atomic operations. This is currently configured by
a formal boolean parameter, but this could be computed automatically using
some info from System.Soft_Links for instance.

Proposal for storage pools (OA09-038)
-------------------------------------

Some packages need to perform memory allocation. In all such cases, we declare
a formal generic package that provides the storage pools to use, so that users
have ultimate control over memory allocation (for instance, the nodes packages
themselves control how many allocations are taking place, and the storage pools
control how they are actually performed).

Rather than pass a single object of type access to Root_Storage_Pool'Class, we
pass both a type for the storage pool, and an object access to that type. This
is to avoid dynamic dispatching when calling the pool, since in some contexts
like libadalang, with highly optimized pools, it has been shown that the cost
of dispatching might become significant.

The drawback is that a formal package parameter cannot have a default value
(nor can a type, of course), so a user systematically has to provide a value.
But this is only when using the low-level generic packages. When using the
higher-level packages, they still simply take an Element_Type, and the
storage_pool is always the default global pool.

Misc Proposals
--------------

- Some example of code is provided that tests the various proposals against
  Ada2012 and C++ STL containers.

- Manu: The for..of loop is really nice when writting code.
  In its current implementation, though, it is grossly inefficient (see the
  results in the test and LC14-015) because the standard forces the use of
  controlled types.
  One proposal is to reuse the gnat-specific Iterable aspect, which is just
  a thin wrapper around First, Has_Element, Element and Next. This loop is
  as fast as manipulating the cursors directly.

  Implementation detail: the Iterable pragma does not work when the element
    type is unconstrained. This could likely be improved by generating a
    local declare block in such cases.

- Manu: In C++ STL, none of the methods are virtual, for efficiency.
  The equivalent in Ada is be to make all the cursor operations use
  non-dispatching operations, with a 'Class parameter.
  One limitation is that this doesn't work with the Iterable aspect, but this
  could presumably be enhanced (this is why the for..of loop in the example
  is currently twice as slow as the explicit loop, that's the cost of
  dynamic dispatching).

- Manu: code should be compiled with -gnatp for efficiency.
  To leave some safety for users that want/need it, we can add a new formal
  boolean parameter that tells the compiler whether to add explicit checks.

Running the test
----------------

gprbuild -Pdefault
./perf

Todo
----

- Algorithms
  We should have a version of the algorithms that take two cursors, when
  we only want to work on a subset of the container. The second cursor is,
  as in C++, past the last element in the sequence, to simplify the
  handling of containers like forward-lists. The value Null_Access would
  be used to indicate the end of the container.

- Reverse and non-constant cursors

- Ideas:
  * for lists, could write a type of Nodes_Traits for a database query.
    Or perhaps just as a cursors_traits, but then we do not get the for..of
    loop

  * Boolean formal parameter to configure whether we should add locking every
    time we do operations. Can we do this through a hidden protected object
    with barriers, or do we need to make the barriers visible in the API,
    which would not be possible

  * Support for reference counted containers (a la QGen), as a further
    derivation of the Lists.Indefinite_Unbounded.List type
    Support for copy-on-write, perhaps through a formal generic callback
    every time the container is about to be modified.

  * Document how to use a 'with' clause to get access to the operations
    when one doesn't want to use the prefix notation for calls

  * A boolean formal parameter to enable tampering checks ?

  * A version of some algorithms that are multi-threaded

  * Indefinite_Element_Traits: move Element_Access to private part of nested
    package (for SPARK)
    For SPARK, the reference_type will be a null record, since SPARK cannot
    use access types anyway.

  * Rename the formal parameter Reference_Type to a more general name, since
    it need now be implemented as a reference_type. For instance, in the case
    of definite elements, it is directly the element_type (which in fact does
    not allow modifying the element, so might not be appropriate).
    Can we implement the reference types outside of the element_traits
    package, to simplify them ?

  * Use the Variable_Indexing aspect on containers

  * QT containers provide copy-on-write. When a type is "movable", they use
    realloc, by increments of page size (4096 bytes), since modern operating
    systems will not copy the memory in such case but simply reorder the
    pages and only the first and last pages are copied.
    For non-movable types , grow by 50%.
    QT ordered map uses skip-list instead of red-black-tree since the former
    results in less code and uses less memory per node.

- Extensions
  * Have the Iterable aspect take a Constant_Forward_Cursors_Traits instead
    of all the subprograms.

  * How can we use a "for..of" loop when writting an algorithm ?


Performance results
-------------------

A previous experiment shows the importance of the cache in such tests: using
a single-linked-list instead of a doubly-linked list takes the following time
to insert and traverse 10_000_000 integers:

                          forward-list  doubly-linked
      10_000_000 inserts   0.46454        0.52211
      traversing list      0.150259       0.25763

Outcome tickets
---------------

The work on this library generated a number of discussions and improvements
to the compiler or the runtime.

O511-005 using Iterable aspect with indefinite types
   The Iterable aspect was not usable with unconstrained element types
O521-013 limited reference_type are slow
O505-018 Improve efficient of for-of loop with indefinite element types
O426-003 / N422-001   Suppressing checks in containers
OA12-017 Iterable aspect applied to class-wide operations

Could not find the tickets for:
   - passing reference types on the stack rather than secondary stack
     (since their size is known at compile time)
O403-028 Reference_Types are unconstrained types passed on secondary stack

