
Designing new efficient containers
==================================

Goals
-----

- Containers should be efficient
  We will compare with other languages (C++, Python and Lua)

- We need to be able to add preconditions
  In particular, we need containers for SPARK. They do not have to share
  implementation with containers used in other contexts, but it would be
  nice if we could share the spec.
  Technically speaking, one of the things this imposes is to pass the
  container in parameter to the various cursor functions (Element, First,...)
  and avoid dynamic memory allocations.

- Containers must be readable from multiple tasks in parallel
  No writting in flags for instance (M223-003)

- We would like to avoid the multiplication of packages for Bounded/Unbounded,
  constrained/indefinite, formal or not,...

- Avoid a case with dangling cursors (M124-015)
  If we write a function that returns a container, and use it as:

      declare
         C : Cursor := My_Function.First;
      begin
         ... C references deallocated memory since My_Function's result
         ... has been finalized

Proposal for using tagged types
-------------------------------

For the convenience of using the dot-notation for calling primitive operations,
we are making all containers tagged types.

However, they are not meant to be subclassed, and thus most operations are
class-wide. This provides maximum efficient (no dynamic dispatching), and
matches what is done in the C++ STL (no virtual methods).

The cursors themselves are not tagged. All cursor operations take both the
container and the cursor in parameter (to support bounded containers), and
thus the container is used in the dot-notation call (Self.Has_Element (Pos)).

Implementation Note: currently, the Iterable aspect requires primitive
  operations, which make it slow. It should be enhanced to accept class-wide
  operations instead, which would also remove a number of primitive operations
  on the container types.

Proposal for sharing generic algorithms
---------------------------------------

- One of the very strong limitations of the Ada containers is that they have
  no relationship with each other. As such, if we want to write an algorithm
  that counts the number of items that match a predicate, we will need several
  packages. Since lists themselves have no relationship with each other, these
  have to be generic packages specialized for each container:

     generic
        with package Lists is new Doubly_Linked_Lists (<>);
     procedure Algo;

  Let's make the algorithm container-independent. One possibility is to pass
  instead lots of formal generic parameters that describe how to manipulate
  the list and its cursors:

     generic
        type List is tagged private;
        type Cursor is private;
        with function First (Self : List) return Cursor is <>;
        ...
     procedure Algo;

  This works, but is not very convenient to instantiate, even when using
  default values for the subprogram parameters.

  The approach proposed in our new containers is to group these generic
  parameters into a set of Traits packages. These traits packages are only
  used as a grouping of parameters, and have no body. So our algorithm
  above would be declared as:

     generic
        with package Cursors is new Forward_Cursor_Traits (<>);
     procedure Algo;

  and all the functions to manipulate the cursor are available by accessing
  actual parameters of the Cursors package.

  Several such traits packages are declared in conts.ads, to describe how
  to access elements (Conts.Element_Traits) whether they are definite or
  indefinite; how to manipulate cursors (forward, bidirectional, ...)

  All provided containers will pre-instantiate those traits as appropriate,
  in particular the cursor traits. Algorithms should then be written as
  described above. In fact, it is possible to instantiate those traits
  packages for other types of containers, like the Ada containers, or even
  standard Ada arrays, as show in conts-adaptors.ads.
   
  With this in place, the Count_If algorithm is written only once for all
  containers that we test (definite/indefinite, Ada2012 containers or standard
  Ada arrays).

  This technique is inspired by what C++ does. In particular, the Boost Graph
  library uses it for all graph algorithms, so that they can be used on
  user-specific data structures, not just on a graph type provided by Boost.

- By convention, all _Traits packages have a plural in their name, as in
  Cursors_Traits, Elements_Traits, List_Nodes_Traits.

Proposal for sharing code
-------------------------

Currently, there is no sharing of code between Doubly_Linked_Lists,
and Indefinite_Doubly_Linked_Lists, Bounded_Doubly_Linked_Lists and
Formal_Doubly_Linked_Lists.

The proposal here is to share as much code as possible, through additional
formal generic parameters. With these, containers have several orthogonal
properties:

   - whether they accept definite or indefinite elements.
     This is configured by passing an Elements_Traits package, which is in
     charge of converting to an access type in the case of indefinite
     elements (an alternative implementation could be to reserve the maximum
     space for the element, as done in the current formal containers)

   - whether they are bounded or unbounded
     This is configured by passing a List_Nodes_Traits package. This is in
     charge of allocating the nodes, either on the heap, or as part of a
     statically allocated array of nodes. One other possible implementation
     for SPARK is to have cursors be an index into an array of access types,
     which is safer than having cursors be access types themselves and is
     needed to write some of the post conditions.

   - whether they are controlled or limited types
     The full semantics of containers a-la Ada containers requires having
     controlled types, in particular so that assignment create a copy of
     the container (or possibly a lazy copy) and automatically free
     memory.
     Alternatively, SPARK does not support controlled types, so we want to
     provide another hierarchy of limited non-controlled containers. This
     implementation provides no automatic free of the memory, the user is
     responsible for calling Clear explicitly (and the implementation in
     the nodes and element traits package an decide to do not actual free
     at all).

So a bounded-definite container does not memory allocation;
a bounded-indefinite container does one memory allocation for each element;
an unbounded-definite container does one memory allocation for each node;
an unbounded-indefinte container does two memory allocations per element.
     
Misc Proposals
--------------

- Some example of code is provided that tests the various proposals against
  Ada2012 and C++ STL containers.

- Manu: The for..of loop is really nice when writting code.
  In its current implementation, though, it is grossly inefficient (see the
  results in the test and LC14-015) because the standard forces the use of
  controlled types.
  One proposal is to reuse the gnat-specific Iterable aspect, which is just
  a thin wrapper around First, Has_Element, Element and Next. This loop is
  as fast as manipulating the cursors directly.

  Implementation detail: the Iterable pragma does not work when the element
    type is unconstrained. This could likely be improved by generating a
    local declare block in such cases.

- Manu: In C++ STL, none of the methods are virtual, for efficiency.
  The equivalent in Ada is be to make all the cursor operations use
  non-dispatching operations, with a 'Class parameter.
  One limitation is that this doesn't work with the Iterable aspect, but this
  could presumably be enhanced (this is why the for..of loop in the example
  is currently twice as slow as the explicit loop, that's the cost of
  dynamic dispatching).

- Manu: code should be compiled with -gnatp for efficiency.
  To leave some safety for users that want/need it, we can add a new formal
  boolean parameter that tells the compiler whether to add explicit checks.

Running the test
----------------

gprbuild -Pdefault
./perf

Todo
----

- Use reference_type similar for Element, with automatic derefence, so that
  indefinite containers can have a single Element instead of also having
  Stored_Element for efficiency.
  A similar solution is also needed to prevent users from freeing the access
  type returned by Stored_Element, or modifying the pointed element in place
  (which is incorrect for some containers)
  Using a reference seems much slower than using an access to element_type,
  even though the reference is not controlled.
  Can we store the reference directly in the container ?

- Array adaptors
  Would be nice if there was a way not to pass the index_type and
  component_type explicitly as part of the formal containers ?
  (perhaps a Arr'Component_Type) ?

- SPARK
  needs limited, non-controlled containers (could be done in conts-lists.ads,
  not in conts-lists_impl.ads). Controlled can be done through another Traits
  package.
  Need an implementation of cursors for unbounded containers where the cursor
  is an index into an array of access types. We do not want to use access
  types directly, since that makes it harder to write post-condition using the
  old and new value of iterators.

- Support for the Q-Gen containers (N625-026)
  Basically, we want a container of Root'Class, for which the for..of loop
  returns a child type.
     Given type Child1 is new Root with private;
     Thn   for E of Child1_List loop    --   E is a Child1'Class
     And   for E of Child2_List loop    --   E is a Child2'Class
  without having to re-instantiate the container every time

Performance results
-------------------

+--------- lists of integers
                  | fill         || explicit loop| for..of      | count_if     |
C++               | 100%         || 100%         | 187%         | 86%          |
Array             | 3%           || 24%          | 24%          | 23%          |
Ada (definite)    | 105%         || 121%         | 1839%        | 103%         |
Ada (indefinite)  | 192%         || 174%         | 1859%        | 166%         |
Tagged types      | 109%         || 171%         |
Lists (u-d-c)     | 91%          || 116%         | 177%(1)      | 92%          |FinalizeFinalize
Lists (u-i-c)     | 182%         || 215%         | 227%(1)      | 178%         |FinalizeFinalize
Lists (b-d-c)     | 8%           || 77%          | 157%(1)      | 72%          |FinalizeFinalize
Lists (b-d-l)     | 8%           || 72%          | 153%(1)      | 72%          |

+--------- lists of strings or std::string
                  | fill         || explicit loop| for..of      | count_if     |
C++               | 100%         || 100%         | 354%         | 122%         |
Ada indefinite    | 88%          || 248%         | 739%         | 246%         |
Lists (u-i-c)     | 79%          || 264%         | (2)          | 218%         |Finalize
Lists (u-i-c) (3) | 77%          || 67%          | (2)          | 77%          |Finalize

b-/u-: (un)bounded  (d-/i-): (in)definite  (c/l): controlled/limited
(1): slower because Iterable aspect needs primitive operations
(2): Iterable does not support unconstrained elements
(3): Using Stored_Element instead of Element

