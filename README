
Designing new efficient containers
==================================

Goals
-----

- Containers should be efficient
  We will compare with other languages (C++, Python and Lua)

- We need to be able to add preconditions
  In particular, we need containers for SPARK. They do not have to share
  implementation with containers used in other contexts, but it would be
  nice if we could share the spec.
  Technically speaking, one of the things this imposes is to pass the
  container in parameter to the various cursor functions (Element, First,...)
  and avoid dynamic memory allocations.

- Containers must be readable from multiple tasks in parallel
  No writting in flags for instance (M223-003)

- We would like to avoid the multiplication of packages for Bounded/Unbounded,
  constrained/indefinite, formal or not,...

- Avoid a case with dangling cursors (M124-015)
  If we write a function that returns a container, and use it as:

      declare
         C : Cursor := My_Function.First;
      begin
         ... C references deallocated memory since My_Function's result
         ... has been finalized

Proposal for sharing generic algorithms
---------------------------------------

- One of the very strong limitations of the Ada containers is that they have
  no relationship with each other. As such, if we want to write an algorithm
  that counts the number of items that match a predicate, we will need several
  packages. Since lists themselves have no relationship with each other, these
  have to be generic packages:
     generic
        with package Lists is new Doubly_Linked_Lists (<>);
     procedure Algo;

  One alternative is to pass instead lots of formal generic parameters that
  describe how to manipulate the list and its cursors:
     generic
        type List is tagged private;
        type Cursor is private;
        with function First (Self : List) return Cursor;
        ...
     procedure Algo;

  The approach proposed in our new containers is to group these generic
  parameters into a set of Traits packages. These traits packages are only
  used as a grouping of parameters, and have no body. So our algorithm
  above would be declared as:
     generic
        with package Cursors is new Forward_Cursor_Traits (<>);
     procedure Algo;
  and all the functions to manipulate the cursor are available by accessing
  actual parameters of the Cursors package.

  Several such traits packages are declared in conts.ads, to describe how
  to access elements (Conts.Element_Traits) whether they are definite or
  indefinite; how to manipulate cursors (forward, bidirectional, ...)

  All provided containers will pre-instantiate those traits as appropriate,
  in particular the cursor traits. Algorithms should then be written as
  described above. In fact, it is possible to instantiate those traits
  packages for other types of containers, like the Ada containers, or even
  standard Ada arrays, as show in conts-adaptors.ads.
   
  With this in place, the Count_If algorithm is written only once for all
  containers that we test (definite/indefinite, Ada2012 containers or standard
  Ada arrays).

  This technique is inspired by what C++ does. In particular, the Boost Graph
  library uses it for all graph algorithms, so that they can be used on
  user-specific data structures, not just on a graph type provided by Boost.

- By convention, all _Traits packages have a plural in their name, as in
  Cursors_Traits, Elements_Traits, List_Nodes_Traits.

Proposal for sharing code
-------------------------

Currently, there is no sharing of code between Doubly_Linked_Lists,
and Indefinite_Doubly_Linked_Lists, Bounded_Doubly_Linked_Lists and
Formal_Doubly_Linked_Lists.

The proposal here is to share as much code as possible, through additional
formal generic parameters. For instance, by providing a traits package for
Elements, we can handle constrained and unconstrained elements with the
same code (and an additional conversion operator for an element_type to
an access to it in the case of unconstrained types).

Likewise, bounded and unbounded implementations are mostly the same once we
abstract the type of nodes.

Misc Proposals
--------------

- Some example of code is provided that tests the various proposals against
  Ada2012 and C++ STL containers.

- Manu: for ease of use, I propose to make container types tagged
  This means that we can use the nice Ada2012 dot notation to call the
  operations.

- Manu: The for..of loop is really nice when writting code.
  In its current implementation, though, it is grossly inefficient (see the
  results in the test and LC14-015) because the standard forces the use of
  controlled types.
  One proposal is to reuse the gnat-specific Iterable aspect, which is just
  a thin wrapper around First, Has_Element, Element and Next. This loop is
  as fast as manipulating the cursors directly.

  Implementation detail: the Iterable pragma does not work when the element
    type is unconstrained. This could likely be improved by generating a
    local declare block in such cases.

- Manu: In C++ STL, none of the methods are virtual, for efficiency.
  The equivalent in Ada is be to make all the cursor operations use
  non-dispatching operations, with a 'Class parameter.
  One limitation is that this doesn't work with the Iterable aspect, but this
  could presumably be enhanced (this is why the for..of loop in the example
  is currently twice as slow as the explicit loop, that's the cost of
  dynamic dispatching).

- Manu: code should be compiled with -gnatp for efficiency.
  To leave some safety for users that want/need it, we can add a new formal
  boolean parameter that tells the compiler whether to add explicit checks.

Running the test
----------------

gprbuild -Pdefault
./perf

Todo
----

- Use reference_type similar for Element, with automatic derefence, so that
  indefinite containers can have a single Element instead of also having
  Stored_Element for efficiency.
  A similar solution is also needed to prevent users from freeing the access
  type returned by Stored_Element, or modifying the pointed element in place
  (which is incorrect for some containers)
  Using a reference seems much slower than using an access to element_type,
  even though the reference is not controlled.
  Can we store the reference directly in the container ?

- Array adaptors
  Would be nice if there was a way not to pass the index_type and
  component_type explicitly as part of the formal containers ?
  (perhaps a Arr'Component_Type) ?

- SPARK
  needs limited, non-controlled containers (could be done in conts-lists.ads,
  not in conts-lists_impl.ads). Controlled can be done through another Traits
  package.
  Need an implementation of cursors for unbounded containers where the cursor
  is an index into an array of access types. We do not want to use access
  types directly, since that makes it harder to write post-condition using the
  old and new value of iterators.

- Support for the Q-Gen containers (N625-026)
  Basically, we want a container of Root'Class, for which the for..of loop
  returns a child type.
     Given type Child1 is new Root with private;
     Thn   for E of Child1_List loop    --   E is a Child1'Class
     And   for E of Child2_List loop    --   E is a Child2'Class
  without having to re-instantiate the container every time

Performance results
-------------------

+--- lists of integers ---------------------------------------------------+
Type              | fill        |explicit loop| for..of     | count_if    |
+-----------------+-------------+-------------+-------------+-------------+
Lists (definite)  | 0.03733     | 0.00169     | 0.00310(1)  | 0.00162     |
Lists (indefinite)| 0.06285     | 0.00237     | 0.00303(1)  | 0.00236     |
Lists (bounded)   | 0.00224     | 0.00137     | 0.00298(1)  | 0.00139     |
C++               | 0.03202     | 0.00162     | 0.00325     | 0.00156     |
Arrays            | 0.00027     | 0.00045     | 0.00044     | 0.00042     |
Ada2012           | 0.03553     | 0.00189     | 0.03251     | 0.00160     |
Ada2012 (indef)   | 0.06066     | 0.00252     | 0.03235     | 0.00235     |
Tagged            | 0.03474     | 0.00349     |

+--- lists of strings (test if first char is s) --------------------------+
Lists             | 0.05723     | 0.01332     |          (2)| 0.00989     |
Lists (3)         | 0.06163     | 0.00256     |          (2)| 0.00238     |
C++               | 0.07475     | 0.00334     | 0.01164     | 0.00337     |
Ada2012           | 0.06561     | 0.01154     | 0.03193     | 0.01121     |

(1): slower because Iterable aspect needs primitive operations
(2): Iterable does not support unconstrained elements
(3): Using Stored_Element instead of Element
