
Designing new efficient containers
==================================

Goals
-----

- Containers should be efficient
  We will compare with other languages (C++, Python and Lua)

- We need to be able to add preconditions
  In particular, we need containers for SPARK. They do not have to share
  implementation with containers used in other contexts, but it would be
  nice if we could share the spec.
  Technically speaking, one of the things this imposes is to pass the
  container in parameter to the various cursor functions (Element, First,...)
  and avoid dynamic memory allocations.

- Containers must be readable from multiple tasks in parallel
  No writting in flags for instance (M223-003)

- We would like to avoid the multiplication of packages for Bounded/Unbounded,
  constrained/indefinite, formal or not,...

- Avoid a case with dangling cursors (M124-015)
  If we write a function that returns a container, and use it as:

      declare
         C : Cursor := My_Function.First;
      begin
         ... C references deallocated memory since My_Function's result
         ... has been finalized

Proposal for using tagged types
-------------------------------

For the convenience of using the dot-notation for calling primitive operations,
we are making all containers tagged types.

However, they are not meant to be subclassed, and thus most operations are
class-wide. This provides maximum efficient (no dynamic dispatching), and
matches what is done in the C++ STL (no virtual methods).

The cursors themselves are not tagged. All cursor operations take both the
container and the cursor in parameter (to support bounded containers), and
thus the container is used in the dot-notation call (Self.Has_Element (Pos)).

Implementation Note: currently, the Iterable aspect requires primitive
  operations, which make it slow. It should be enhanced to accept class-wide
  operations instead, which would also remove a number of primitive operations
  on the container types.

Proposal for sharing generic algorithms
---------------------------------------

- One of the very strong limitations of the Ada containers is that they have
  no relationship with each other. As such, if we want to write an algorithm
  that counts the number of items that match a predicate, we will need several
  packages. Since lists themselves have no relationship with each other, these
  have to be generic packages specialized for each container:

     generic
        with package Lists is new Doubly_Linked_Lists (<>);
     procedure Algo;

  Let's make the algorithm container-independent. One possibility is to pass
  instead lots of formal generic parameters that describe how to manipulate
  the list and its cursors:

     generic
        type List is tagged private;
        type Cursor is private;
        with function First (Self : List) return Cursor is <>;
        ...
     procedure Algo;

  This works, but is not very convenient to instantiate, even when using
  default values for the subprogram parameters.

  The approach proposed in our new containers is to group these generic
  parameters into a set of Traits packages. These traits packages are only
  used as a grouping of parameters, and have no body. So our algorithm
  above would be declared as:

     generic
        with package Cursors is new Forward_Cursor_Traits (<>);
     procedure Algo;

  and all the functions to manipulate the cursor are available by accessing
  actual parameters of the Cursors package.

  Several such traits packages are declared in conts.ads, to describe how
  to access elements (Conts.Element_Traits) whether they are definite or
  indefinite; how to manipulate cursors (forward, bidirectional, ...)

  All provided containers will pre-instantiate those traits as appropriate,
  in particular the cursor traits. Algorithms should then be written as
  described above. In fact, it is possible to instantiate those traits
  packages for other types of containers, like the Ada containers, or even
  standard Ada arrays, as show in conts-adaptors.ads.

  With this in place, the Count_If algorithm is written only once for all
  containers that we test (definite/indefinite, Ada2012 containers or standard
  Ada arrays).

  This technique is inspired by what C++ does. In particular, the Boost Graph
  library uses it for all graph algorithms, so that they can be used on
  user-specific data structures, not just on a graph type provided by Boost.

- By convention, all _Traits packages have a plural in their name, as in
  Cursors_Traits, Elements_Traits, List_Nodes_Traits.

Proposal for sharing code
-------------------------

Currently, there is no sharing of code between Doubly_Linked_Lists,
and Indefinite_Doubly_Linked_Lists, Bounded_Doubly_Linked_Lists and
Formal_Doubly_Linked_Lists.

The proposal here is to share as much code as possible, through additional
formal generic parameters. With these, containers have several orthogonal
properties:

   - whether they accept definite or indefinite elements.
     This is configured by passing an Elements_Traits package, which is in
     charge of converting to an access type in the case of indefinite
     elements (an alternative implementation could be to reserve the maximum
     space for the element, as done in the current formal containers)

   - whether they are bounded or unbounded
     This is configured by passing a List_Nodes_Traits package. This is in
     charge of allocating the nodes, either on the heap, or as part of a
     statically allocated array of nodes. One other possible implementation
     for SPARK is to have cursors be an index into an array of access types,
     which is safer than having cursors be access types themselves and is
     needed to write some of the post conditions.

   - whether they are controlled or limited types
     The full semantics of containers a-la Ada containers requires having
     controlled types, in particular so that assignment create a copy of
     the container (or possibly a lazy copy) and automatically free
     memory.
     Alternatively, SPARK does not support controlled types, so we want to
     provide another hierarchy of limited non-controlled containers. This
     implementation provides no automatic free of the memory, the user is
     responsible for calling Clear explicitly (and the implementation in
     the nodes and element traits package an decide to do not actual free
     at all).

   - whether they are meant for SPARK usage
     Unbounded containers in SPARK are allowed to allocate memory, but we
     want the pointers to be indexes into a table, not direct pointers.
     This is safer, but also eases the writting of post-conditions since
     the value of the cursor is the same before and after an insert or a
     copy for instance.
     This is implemented as a new nodes_traits, similar to bounded and
     unbounded.

So a bounded-definite container does not memory allocation;
a bounded-indefinite container does one memory allocation for each element;
an unbounded-definite container does one memory allocation for each node;
an unbounded-indefinte container does two memory allocations per element.

Proposal for performance
------------------------

The overall goal is to get as good a performance as possible.
We propose not to use controlled types unless explicitly requested by the
user. We also propose not to handle bits in the container to invalid
containers when a container has been modified. These costs a lot (both
in performance and because this requires write access to the container
even for read-only operations, hence the user of unchecked_access).

An experiment has been done in using Reference_Type to speed up access
to data in indefinite containers. In practice, this seems slow because
a reference_type is an unconstrained type, so it might be better for
users to keep using an element_access.

Using the realloc() system call leads to large improvements over
systematically allocating a new array, copying the old, and freeing the
old. One of the drawbacks is that users should not put controlled types
that need to access their address into such a table.
This seems like an acceptable limitation given the very significant
speed improvements.
Unfortunately, there is no way to test whether the user's type conforms to
this requirement.

Misc Proposals
--------------

- Some example of code is provided that tests the various proposals against
  Ada2012 and C++ STL containers.

- Manu: The for..of loop is really nice when writting code.
  In its current implementation, though, it is grossly inefficient (see the
  results in the test and LC14-015) because the standard forces the use of
  controlled types.
  One proposal is to reuse the gnat-specific Iterable aspect, which is just
  a thin wrapper around First, Has_Element, Element and Next. This loop is
  as fast as manipulating the cursors directly.

  Implementation detail: the Iterable pragma does not work when the element
    type is unconstrained. This could likely be improved by generating a
    local declare block in such cases.

- Manu: In C++ STL, none of the methods are virtual, for efficiency.
  The equivalent in Ada is be to make all the cursor operations use
  non-dispatching operations, with a 'Class parameter.
  One limitation is that this doesn't work with the Iterable aspect, but this
  could presumably be enhanced (this is why the for..of loop in the example
  is currently twice as slow as the explicit loop, that's the cost of
  dynamic dispatching).

- Manu: code should be compiled with -gnatp for efficiency.
  To leave some safety for users that want/need it, we can add a new formal
  boolean parameter that tells the compiler whether to add explicit checks.

Running the test
----------------

gprbuild -Pdefault
./perf

Todo
----

- Algorithms
  We should have a version of the algorithms that take two cursors, when
  we only want to work on a subset of the container. The second cursor is,
  as in C++, past the last element in the sequence, to simplify the
  handling of containers like forward-lists. The value Null_Access would
  be used to indicate the end of the container.

- Memory management
  Provide Clear (and support for it in Nodes packages), including
  automatically for controlled containers.

- Ideas:
  * for lists, could write a type of Nodes_Traits for a database query.
    Or perhaps just as a cursors_traits, but then we do not get the for..of
    loop


Performance results
-------------------

+--------- lists of integers
                  | fill    | explicit| for..of | count_if| allocate| allocs  | reallocs| free    |
C++               | 100%    | 100%    | 194%    | 91%     |         |         |         |         |
Array             | 5%      | 40%     | 38%     | 51%     | 9600kb  |  0      |  0      |  0      |
Ada (definite)    | 106%    | 117%    | 1987%   | 98%     | 7200kb  |  300000 |  0      |  0      |
Ada (indefinite)  | 187%    | 167%    | 2065%   | 156%    | 8400kb  |  600000 |  0      |  0      |
Tagged types      | 102%    | 198%    |         |         |         |         |         |         |
Lists (u-d-c)     | 93%     | 116%    | 194%(1) | 100%    | 7200kb  |  300000 |  0      |  0      |
Lists (u-i-c)     | 187%    | 155%    | 193%(1) | 154%    | 8400kb  |  600000 |  0      |  0      |
Lists (u-i-s)     | 97%     | 111%    | 208%(1) | 90%     | 16132kb |  300001 |  31     |  0      |
Lists (b-d-c)     | 8%      | 88%     | 181%(1) | 88%     | 28800kb |  0      |  0      |  0      |
Lists (b-d-l)     | 8%      | 83%     | 182%(1) | 83%     | 28800kb |  0      |  0      |  0      |

+--------- lists of strings or std::string
                  | fill    | explicit| for..of | count_if| allocate| allocs  | reallocs| free    |
C++               | 100%    | 100%    | 326%    | 100%    |         |         |         |         |
Ada indefinite    | 82%     | 312%    | 854%    | 296%    | 13200kb |  600000 |  0      |  0      |
Lists (u-i-c)     | 76%     | 264%    | (2)     | 264%    | 13200kb |  600000 |  0      |  0      |
Lists (u-i-c) (4) | 72%     | 172%    | (2)     | 161%    | 13200kb |  600000 |  0      |  0      |
Lists (u-i-c) (3) | 80%     | 72%     | (2)     | 66%     | 13200kb |  600000 |  0      |  0      |

b-/u-: (un)bounded  (d-/i-): (in)definite (c/l/s): controlled/limited/spark
(1): slower because Iterable aspect needs primitive operations
(2): Iterable does not support unconstrained elements
(3): Using Stored_Element (less safe, user can free pointer)
(4): Using Reference_Type (unconstrained type, slower)




A previous experiment shows the importance of the cache in such tests: using
a single-linked-list instead of a doubly-linked list takes the following time
to insert and traverse 10_000_000 integers:

                          forward-list  doubly-linked
      10_000_000 inserts   0.46454        0.52211
      traversing list      0.150259       0.25763
