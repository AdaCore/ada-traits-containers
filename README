
Designing new efficient containers
==================================

Goals
-----

- Containers should be efficient
  We will compare with other languages (C++, Python and Lua)

- We need to be able to add preconditions
  In particular, we need containers for SPARK. They do not have to share
  implementation with containers used in other contexts, but it would be
  nice if we could share the spec.
  Technically speaking, one of the things this imposes is to pass the
  container in parameter to the various cursor functions (Element, First,...)
  and avoid dynamic memory allocations.

- Containers must be readable from multiple tasks in parallel
  No writting in flags for instance (M223-003)

- We would like to avoid the multiplication of packages for Bounded/Unbounded,
  constrained/indefinite, formal or not,...

- Avoid a case with dangling cursors (M124-015)
  If we write a function that returns a container, and use it as:

      declare
         C : Cursor := My_Function.First;
      begin
         ... C references deallocated memory since My_Function's result
         ... has been finalized

Proposal
--------

- Some example of code is provided that tests the various proposals against
  Ada2012 and C++ STL containers.

- Manu: One of the limitations with the Ada2012 containers is that we cannot
  write algorithms that work with any type of container (for instance counting
  the number of elements matching a criteria) without having a lot of formal
  parameters.
  One proposal is to introduce explicit Traits generic packages.
  See the code in Conts.Forward_Cursors_Traits, and the algorithm in
  Conts.Algorithms.
  This technique is inspired by what C++ does. In particular, the Boost Graph
  library uses it for all graph algorithms, so that they can be used on
  user-specific data structures, not just on a graph type provided by Boost.

  With this in place, the Count_If algorithm is written only once for all
  containers that we test (definite/indefinite, Ada2012 containers or standard
  Ada arrays)

  Implementation detail: because of Ada's freezing rules, we need to define
    the container in another package (conts.lists_impl) and then have
    another package (conts.lists) that instantiate that package and provide
    the various cursors packages.
    This also requires renaming a lot of subprograms for cases when people
    do not use Ada2012 dot notation. These renamings could be generated
    automatically.

- Manu: for ease of use, I propose to make container types tagged
  This means that we can use the nice Ada2012 dot notation to call the
  operations.

- Manu: The for..of loop is really nice when writting code.
  In its current implementation, though, it is grossly inefficient (see the
  results in the test and LC14-015) because the standard forces the use of
  controlled types.
  One proposal is to reuse the gnat-specific Iterable aspect, which is just
  a thin wrapper around First, Has_Element, Element and Next. This loop is
  as fast as manipulating the cursors directly.

  Implementation detail: the Iterable pragma does not work when the element
    type is unconstrained. This could likely be improved by generating a
    local declare block in such cases.

- Manu: In C++ STL, none of the methods are virtual, for efficiency.
  The equivalent in Ada is be to make all the cursor operations use
  non-dispatching operations, with a 'Class parameter.
  One limitation is that this doesn't work with the Iterable aspect, but this
  could presumably be enhanced (this is why the for..of loop in the example
  is currently twice as slow as the explicit loop, that's the cost of
  dynamic dispatching).

- Manu: code should be compiled with -gnatp for efficiency.
  To leave some safety for users that want/need it, we can add a new formal
  boolean parameter that tells the compiler whether to add explicit checks.

Running the test
----------------

gprbuild -Pdefault
./perf

Todo
----

- Use reference_type similar for Element, with automatic derefence, so that
  indefinite containers can have a single Element instead of also having
  Stored_Element for efficiency.
  A similar solution is also needed to prevent users from freeing the access
  type returned by Stored_Element, or modifying the pointed element in place
  (which is incorrect for some containers)

- Implement bounded containers, sharing the same implementation
  Seems like this would be two extra parameters to Conts.Lists_Impl to
  control the allocation and deallocation of nodes. Then
  Conts.Bounded_Lists would subclass the List and have a discriminant
  Capacity, as well as a field for the buffer.
