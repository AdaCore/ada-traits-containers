Various implementations for reference counted types
===================================================

- Using Elements_Traits to describe how to store an element
  This was used so that in simple cases (definite element type) we can save
  one memory allocation. This has been obsoleted by using a storage_pool
  for the Element_Access which stores the refcount next to the element, and
  thus always do a single malloc, for both definite and indefinite elements

Memory management
=================

- The performance of refcounted types is strongly dependent on the number of
  mallocs we need to perform. We always need at least one
  (for the shared data). Without special tricks, we need a second one for the
  refcount itself (since it can't be stored in the Element itself, unless that
  element derives from a known root tagged type as done in the current
  GNATCOLL.Refcount implementation).
  So we implemented a special storage pool, that allocates enough memory for
  the element + its refcount. That way, a single malloc is needed.

                      |Set       |Assign    |Ref       |
   Storing integers
     GNATCOLL         | 100%     | 100%     | 100%     |
     Std Unsafe       | 115%     | 47%      | 538%     |
     Std              | 114%     | 74%      | 532%     |
   Storing strings
     GNATCOLL         | 100%     | 100%     | 100%     |
     Std              | 142%     | 79%      | 89%      |
     Std Free         | 147%     | 78%      | 86%      |
 To
   Storing integers
     GNATCOLL         | 100%     | 100%     | 100%     |
     Std Unsafe       | 39%      | 57%      | 92%      | <<< one malloc, not two
     Std              | 42%      | 96%      | 102%     | <<< one malloc, not two
   Storing strings
     GNATCOLL         | 100%     | 100%     | 100%     |
     Std              | 68%      | 88%      | 95%      |
     Std Free         | 67%      | 85%      | 113%     |

TODO
====

- Can we remove Get completely (need a reference_type to be constraints, for
  instance a default null value for the discriminant)
- Can we remove Set (a storage pool to instrument "new")
- use integer_64 on 64 bits targets, and corresponding builtins in gnatcoll.atomic
- Can we use pragma Atomic ? Does not seem so

References
==========

http://www.codesynthesis.com/~boris/blog/2009/01/11/shared-ptr-counter/
http://www.drdobbs.com/weak-pointers/184402026  (shared_from_this)
http://www.gotw.ca/gotw/043.htm
