TODO -*- mode: org -*-
#+TAGS: PERFORMANCE(p) SPARK(s)
#+TODO: TODO MAYBE DONE

This is a TODO list for the containers library. Not all ideas will be
implemented, most likely, but this is a good list of candidates.
Open with Emacs to use the org-mode for easier editing, although this
can be edited with any text editor.

* General organization of packages

** TODO Decide on whether to use /Traits/ or /Policy/ for the name of packages
   'Policy' templates is the term used in C++ (see
    https://en.wikipedia.org/wiki/Policy-based_design), and that seems closest
    to what we are doing here in practice. A policy is used to inject behavior
    in a parent class, typically through inheritance.  Any time some design
    choice has to be made when implementing an algorithm, then that choice
    should be abstracted in its own policy template. Then the algorithm can be
    used with any version of the policy template, so that it can be used with
    all possible design choices (eventually).

** MAYBE Merge packages (=conts.vectors= and =conts.vectors.nodes= for instance)
   Would limit the number of with clauses in user code.

** MAYBE Use expression functions in private part rather than in the body
   Would this help the compiler inline functions ?

** TODO Replace storage_pools package with higher-level package
   For unbounded vectors, for instance, we want to use directly =System.Memory=
   so that we can also use =realloc=. This is not compatible with storage
   pools, so it would be more convenient to have another traits package, for
   which one of the implementations would be storage pools.
   However, storage pools are used because then we can use the "new" operator
   directly.

** TODO Implement =Checks_Policy= package to add extra checks
   This could also be used to match the semantics of the Ada2012 containers.

** TODO reference-counted containers
   These would support copy-on-write, and would be efficient by avoiding a
   number of copies. They also avoid the limitation of the standard Ada
   containers (see M124-015 below).
   QT provides copy-on-write: when a type is movable, they use realloc,
   by increments of page size (4096 bytes), since modern operating systems will
   not copy the memory in such case, but simply reorder the pages and only the
   first and last page are copied.

** TODO Test that the package work well when not using =use= clauses

** TODO Implement the standard Ada containers on top of these
   We will likely need a =Check_Policy= formal parameter.

** TODO Storage pools: can we pass a subprogram instead
   Is there a way we could pass storage pools as a factory function as formal
   parameter to other packages, rather than as a package ? This would allow
   giving a default value, and would let users override this for their whole
   application.

** TODO Support for standard Ada iterators, rather than =Iterable= aspect
   Measure performance, which might be better since Iterable forces dynamic
   dispatching.

* Elements traits

** TODO Review =Conts.Elements.Arrays=
   It might be more efficient in some cases, but currently leads to a
   =Storage_Error= since we are doing low-level manipulations.
* Algorithms

** TODO =Shuffle=
   Random permutation of random-access data structures

** TODO =Contains=
   Check whether a container contains a specific item

** TODO =Sort=

** MAYBE Should we have a version of the algorithms with two cursors as input ?
   This should allow working on a subset of a container. The second cursor
   might be, as in C++, past the last element of the sequence, to simplify the
   handling of containers like forward-lists.

* Lists

** TODO Implement single-linked lists
   They are much more efficient when they satisfy the user need, as experiments
   showed.

** TODO Implement =Conts.List.Nodes.Unbounded_SPARK= as a vector
   This would avoid code duplication

** MAYBE Implement a version of =Nodes= that perform database queries ?
   This would let users manipulate a database as if they were manipulating
   a list

** TODO pass a storage_pool in parameter to =Unbounded_Spark= nodes

* Queues

** TODO Implement,as  restricted version of =Vector=

* Stacks

** TODO Implement, circular and restricted version of =Vector=

* Vectors

** TODO circular buffer with Prepend operation

** TODO pass a storage_pool in parameter to =Unbounded= nodes

** TODO can a cursor be implemented as an =Index_Type= directly ?
   That would be more logical (removing one layer of abstraction), but
   there is no convenient way to define =No_Element=, and =Next= will
   raise an exception when moving past the current element.

* Maps

** MAYBE QT uses skip-lists instead of red-black-trees
   The former results in less code and uses less memory per node.

* Graphs

** MAYBE Graph layout algorithms (see the one in =Gtkada.Canvas_View=)

** TODO Remove or replace =Glib.Graphs= with our generic implementation

** TODO Remove recursive dfs. Is only used for performance testing

** TODO DFS use a queue for the stack, rather than a vector
   This won't change much, but is slightly better at clarifying the
   intent.

** TODO Implement Adjacency_Matrix data structure

** TODO Implement Linked_Edge representation
   (all edges stored in a single vector, and vertices point into it)

** Algorithms

*** TODO Implement Breadth-First-Search

*** TODO Implement A* algorithm (need priority queue first)

*** MAYBE Iterative version of DFS

** Adjacency lists

*** TODO Version for undirected graph

*** TODO Version for bidirectional graph
    We can access In_Edges in addition to Out_Edges.
    We can provide a =Revert_Graph= wrapper that reverses the direction
    of edges, which is useful for some algorithms

* Priority queues

* Property Maps

** MAYBE should they receive an elements traits rather than =Value=

* Other data structures

** Perhaps a state machine ? (see the one in XML/Ada)

** Perhaps a strings package (so that we can use the algorithms on strings)
   This package would be a wrapper for the various subprograms we have all
   other the place for strings. Supports unicode.

* Testing

** TODO Check that =Copy= works fine in particular for lists

* Documentation

** TODO Document property maps

** TODO Document missing default values for generic formal packages
   Since it is not possible to provide default values for formal packages, we
   have to limit their number when possible.

* Limitations of standard Ada containers

** Dangling cursors (M124-015)
      declare
         C : Cursor := My_Function.First;
      begin
         ... C references deallocated memory since My_Function's result
         ... has been finalized


* Links to other libraries
** Stephe's Ada Library
http://www.sigada.org/ada_letters/sept2004/sal_ada_letters_2004.pdf

** Ada Standard Generic Library
http://www1.cs.columbia.edu/dcc/nestor/presentations/SGL/akonstan-SGL.pdf

** Dynamic arrays (with gaps)
http://en.m.wikipedia.org/wiki/Dynamic_array
http://java.dzone.com/articles/gaplist-%E2%80%93-lightning-fast-list

** Stree
http://www.codeproject.com/Articles/27799/Stree-A-fast-std-map-and-std-set-replacement

** CGAL
http://doc.cgal.org/latest/Manual/packages.html

** Unrolled linked lists
http://en.m.wikipedia.org/wiki/Unrolled_linked_list

** Smart Pointers
http://ootips.org/yonat/4dev/smart-pointers.html

* org-mode help
  *bold* /italic/ _underlined_  =code= ~verbatim~
  See http://orgmode.org/worg/org-tutorials/org4beginners.html

#+BEGIN_SRC python
   def foo:
      if a:
         pass
#END_SRC
