TODO -*- mode: org -*-
#+TAGS: PERFORMANCE(p) SPARK(s)
#+TODO: TODO MAYBE DONE

This is a TODO list for the containers library. Not all ideas will be
implemented, most likely, but this is a good list of candidates.
Open with Emacs to use the org-mode for easier editing, although this
can be edited with any text editor.

* General organization of packages

** MAYBE Merge packages (=conts.vectors= and =conts.vectors.nodes= for instance)
   Would limit the number of with clauses in user code.

** TODO Replace storage_pools package with higher-level package
   For unbounded vectors, for instance, we want to use directly =System.Memory=
   so that we can also use =realloc=. This is not compatible with storage
   pools, so it would be more convenient to have another traits package, for
   which one of the implementations would be storage pools.
   However, storage pools are used because then we can use the "new" operator
   directly.

** TODO Implement =Checks_Policy= package to add extra checks
   This could also be used to match the semantics of the Ada2012 containers.

** TODO reference-counted containers
   These would support copy-on-write, and would be efficient by avoiding a
   number of copies. They also avoid the limitation of the standard Ada
   containers (see M124-015 below).
   QT provides copy-on-write: when a type is movable, they use realloc,
   by increments of page size (4096 bytes), since modern operating systems will
   not copy the memory in such case, but simply reorder the pages and only the
   first and last page are copied.

** TODO Test that the package work well when not using =use= clauses

** TODO Implement the standard Ada containers on top of these
   We will likely need a =Check_Policy= formal parameter.

** TODO Storage pools: can we pass a subprogram instead
   Is there a way we could pass storage pools as a factory function as formal
   parameter to other packages, rather than as a package ? This would allow
   giving a default value, and would let users override this for their whole
   application.

** TODO Support for standard Ada iterators, rather than =Iterable= aspect
   Measure performance, which might be better since Iterable forces dynamic
   dispatching.

** MAYBE persistent data structures
   By implementing specific storage pools or node packages, we could have
   data structures directly mapped to files (perhaps via mmap) ?

** TODO ranges
   Similar to the C++ concept, these are ways to apply algorithms to whole
   containers of subsets of them, and dynamically filter them for instance.
   Since we use a sentinel Has_Element to find the else of a sequence, we
   have good basis in place (it is easy to implement ranges like Iota,
   which returns an infinite sequence of integers, or Repeat, which repeats
   the same element forever). We then need a version of the algorithms that
   take a range in parameter, so that we can apply operators like Take,
   to only keep the n first elements of the range, or Group_By.

* Elements traits

** TODO Review =Conts.Elements.Arrays=
   It might be more efficient in some cases, but currently leads to a
   =Storage_Error= since we are doing low-level manipulations.

** MAYBE merge conts-elements-indefinite and indefinite_spark
   The access type should never be shown in fact.

* Algorithms

** TODO =Shuffle=
   Random permutation of random-access data structures

** TODO =Contains=
   Check whether a container contains a specific item

** TODO =Sort=

** TODO =Equal=
   Compares two containers, ignore order when relevant.
** MAYBE Should we have a version of the algorithms with two cursors as input ?
   This should allow working on a subset of a container. The second cursor
   might be, as in C++, past the last element of the sequence, to simplify the
   handling of containers like forward-lists.

* Cursors

** TODO Non-constant cursors and property maps
   Currently, we associate the Set_Element operation with the cursors, and it
   always takes a Container as the first parameter. Should algorithms instead
   require a constant cursor, and a separate property map.
   Perhaps likewise for getting the elements ?
   This decoupling makes it a bit more complex to instantiate algorithms, but
   provides much more flexibility since the property map might be an
   indirection.
   This perhaps also removes the need for the _Convert variants of the
   algorithms.
   http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1873.html

** TODO =Reverse_Cursor=
   Reverses the order of a bidirectional cursor. This is tricky, since we
   need to know the last iterator (the starting point for the reverse
   iterator), but we only have the Has_Element sentinel.
   The design on C++ ranges at
        http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4128.html#proposed-design
   section 3.3.12 suggests to do a probe O(n) for the last element, since
   that doesn't change the algorithmic complexity.

* Lists

** TODO Implement single-linked lists
   They are much more efficient when they satisfy the user need, as experiments
   showed.

** TODO Implement =Conts.List.Nodes.Unbounded_SPARK= as a vector
   This would avoid code duplication

** MAYBE Implement a version of =Nodes= that perform database queries ?
   This would let users manipulate a database as if they were manipulating
   a list

** TODO pass a storage_pool in parameter to =Unbounded_Spark= nodes

* Queues

** TODO Implement,as  restricted version of =Vector=

* Stacks

** TODO Implement, circular and restricted version of =Vector=

* Vectors

** TODO circular buffer with Prepend operation

** TODO pass a storage_pool in parameter to =Unbounded= nodes

** TODO can a cursor be implemented as an =Index_Type= directly ?
   That would be more logical (removing one layer of abstraction), but
   there is no convenient way to define =No_Element=, and =Next= will
   raise an exception when moving past the current element.

* Maps

** TODO Bounded maps
   Should not allocated any memory

** MAYBE QT uses skip-lists instead of red-black-trees
   The former results in less code and uses less memory per node.

* Graphs

** MAYBE Graph layout algorithms (see the one in =Gtkada.Canvas_View=)

** TODO Remove or replace =Glib.Graphs= with our generic implementation

** TODO Remove recursive dfs. Is only used for performance testing

** TODO DFS use a queue for the stack, rather than a vector
   This won't change much, but is slightly better at clarifying the
   intent.

** TODO Implement Adjacency_Matrix data structure

** TODO Implement Linked_Edge representation
   (all edges stored in a single vector, and vertices point into it)

** Algorithms

*** TODO Implement Breadth-First-Search

*** TODO Implement A* algorithm (need priority queue first)

*** MAYBE Iterative version of DFS

** Adjacency lists

*** TODO Version for undirected graph

*** TODO Version for bidirectional graph
    We can access In_Edges in addition to Out_Edges.
    We can provide a =Revert_Graph= wrapper that reverses the direction
    of edges, which is useful for some algorithms

* Priority queues

* Other data structures

** Perhaps a state machine ? (see the one in XML/Ada)

** Perhaps a strings package (so that we can use the algorithms on strings)
   This package would be a wrapper for the various subprograms we have all
   other the place for strings. Supports unicode.

* Testing

** TODO Can we declare a vector indexed on =Integer=
   This would be a plus compared to the standard Ada containers.

** TODO Check that =Copy= works fine in particular for lists
** TODO Check that all simple containers provide the same ops
   In particular, they should all redefine the iterable aspect,
   as well as the copy function, and perhaps various operators.
   These tests should be generated automatically.

** TODO Force dynamic dispatching in performance tests
   The nested procedure should take a 'Class parameter. This shows
   the cost of dynamic dispatching (significant in for-of loop,
   since the aspect =Iterable= forces it).
   For now, since we also do not force it in C++, we let the
   compiler resolve it statically.

* Documentation

** TODO Document property maps

** TODO Document cursors
   As opposed to C++, we chose to use the usual Ada =Has_Element= function
   rather than pass a past-the-end value. This is more compatible with
   using enumeration types to index a vector, for instance, since there is not
   past-the-end value in such a case.
   Document why we pass the container to all cursor operations: for SPARK,
   because this does not require the use of a Unchecked_Access, and because
   this avoids dangling pointers.

** TODO Document how to design a new container
   Get an implementation that works, then generalize all pieces of code where
   choices had to be made, then provide bounded implementations, then write
   tests.

* Limitations of standard Ada containers

** Dangling cursors (M124-015)
      declare
         C : Cursor := My_Function.First;
      begin
         ... C references deallocated memory since My_Function's result
         ... has been finalized


* Links to other libraries
** Stephe's Ada Library
http://www.sigada.org/ada_letters/sept2004/sal_ada_letters_2004.pdf

** Ada Standard Generic Library
http://www1.cs.columbia.edu/dcc/nestor/presentations/SGL/akonstan-SGL.pdf

** Dynamic arrays (with gaps)
http://en.m.wikipedia.org/wiki/Dynamic_array
http://java.dzone.com/articles/gaplist-%E2%80%93-lightning-fast-list

** Stree
http://www.codeproject.com/Articles/27799/Stree-A-fast-std-map-and-std-set-replacement

** CGAL
http://doc.cgal.org/latest/Manual/packages.html

** Unrolled linked lists
http://en.m.wikipedia.org/wiki/Unrolled_linked_list

** Smart Pointers
http://ootips.org/yonat/4dev/smart-pointers.html

* Optimizations

** C++ Small String Optimization (SSO)
   Newer versions of the stl no longer use copy-on-write for std::string, since
   that doesn't always work correctly with threads.
   However, they have an optimization in place so that small strings do not
   require malloc. This is what we are doing in =Conts.Elements.Arrays=, but
   with lots of space optimization as well.
   Some implementations do this by using one bit to store whether this is a
   long or short string, and this bit is stored as part of the size.
   See http://info.prelert.com/blog/cpp-stdstring-implementations.

** C++ Growing strategies
   Some stl implementation will grow data structures by multiplying their size
   by 1.5, but when the data structure becomes larger they try to allocate
   multiples of the page size (4096 bytes typically).

** Custom allocators
   See https://www.youtube.com/watch?v=LIb3L4vKZ7U

* org-mode help
  *bold* /italic/ _underlined_  =code= ~verbatim~
  See http://orgmode.org/worg/org-tutorials/org4beginners.html

#+BEGIN_SRC python
   def foo:
      if a:
         pass
#END_SRC
